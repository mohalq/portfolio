<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>صفحة الاعمال</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: rgb(64, 7, 118);
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: rgb(64, 7, 118);
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: rgb(64, 7, 118);
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">صفحة الاعمال</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="كلمة السر"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            تذكر معلوماتي
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="فتح التشفير" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"913008943d04784c89960d53ba250ac2a2a5227d35548c2b3bc0abde011621e2dbb1a09e93e00a3369327f78d802c1211ac4b06dd722419fb1a86c2aa3cf4335b591991ca235ee2e4be5d581d9f6fc9cae15d81073a7a764b4cc7731aec836d9b3d47da4a567d6f974158362c633208d03eaa9f741d604b9a9050ec69be03785ae980685fdbb2c701bf035877df75cb2950ed06db8f36ea95f4bb2f0e92e9864d359c034730b5ebb30f1adc42eda562df7cfafb1a313478c34e73520217deb5807e1911c28c3e72623036f862803dc9bc0bb985da5d7d4a089abb40176bb0cabaca0707252b0d268ebc3449055687bb43080ab12935ff82c55eed257019aa84a9bbf3fff27361346e09be432e692d507a7546e95516c3cce2b513ef346b64752ff14763a6743cf47db4adc40ba99d613a83fa565a828ec29386b913bcfd7d52e51a4ea7618398f62b49ec8a713fc9ade2eb2ac4d85751903d2a9d6c649c8c8d89f02fd751c724ee39d709527566e5ca2680a7a9ab304007052ef2251f0bd8ebc84c6c8c70816d8295c9f8a3bd889a439fa351cf9752a28d6e4aaab9d1d616d18efcfdaf4190634d80bf5214328372f80a6b4f23b0aeec143d519d3dbed453a3af3eaf9e522cf84cadffb66ba558138bc8852d7852538609f2b1ca25ba9402bb2dae55694ffc9d803e91e8e27f23423f92bb1d3441b49da1aa0acb0ac93ad4518396dcd7961b1d50274e59c1dc17264cfc4070988ab95823451622dbabeaaab5036f0baf26d23f682ba5678db3e98c3d5239ce0629a09d96b614f61e75422d58e5ad49ef0e02685aa8e61f1ba182a04a8aecb7234149d2cda7341f8a3eebcd31620e1b651f52611d2d5b52e4afb7f95d4f392a9126e57ffb587b7c88885984ceb3af863dcb6e82bcc941cd7bdfbdef1eb53a19912f7b3cae8709cadce6a8de4834013ebf0833be1fbf9cb4e4c2c6f71bb3d3f1bbf759a386455ec33b8154780aa77ebcddb28076041a534205ca5e44e6451673f21a83ea340d490dd0ee40f62624afce10c0952a60a0a7a524cfc063a0fb8913e45add4607b4740eecc0a63b45923eac0cf19da6120c627759e5b9ee26162f51c5f7b2f20f6ebfa8dddf773c9d9a588cbf924a215194ac0cdba320ad8168b41e5b42e9768fd5229845e3588928cf31f987535d829ebdf8ebe7f91eb5a6ede2307e40c7df12c446c5e92db14b890ba5c2c65de760eee49ca7594f54b97d946040c6eb10a408ad298560cee5ebf0b4d0d81d22cbb203448289f417b2e7da93d978252803d179ebda6183385dac1752ecb920d36634e7241cd68d5d5400ae02d2c82862c961125fe561fc978268de9a51961a8e0ba0d92f73c7356961eb9c47705ca910899b627fa4023ac36ec28483c1e71d1392fb5350f68493b8966cd648db251d7e6fcee2d6a68a2196249ae2be33b4bd8f228354750f8f101f48f1125819d1d969885da26cc480b508040fec28d56cb93434be075109b15cf4115a4cf2e42612c2201e70200b7293f7bcc51fa0ffe6032a175a81dc87c8d23f97e78d6bb13c9bf7b7758d6f68441a62bfa577312720f631893dc6fdbab107d1d2e6244aeac2363ed71302b9f99121aa6e3c3da5d920151c594dfedad8d15500f2a8a690f126203967ae9fd36e16ccbd21c8f4a57d713bd6d08437ebe9a3d4f4f75ff480e2efdb9b2e1bc65b1c325bdae2fc75b76a08fb335c50b55845b938224699c75f0efc911265905f339013f20de457b59cdb136a73859eefba81ff19533dedb2329762f1dec24cff5a55d182dd0a15e3a409080abe563d161da5b045959757e802b2f1a0984c359795d523b659cc385696e79cc686c0e2f0e5ed571aa25168ad2d8be34bfd5cd4ee4038f4ef44a0d02851d8b090774e8ca4574843bc3d362a46782637337ef828e6a91246bb536b34aa281ceee4e9a794ceb1b2ac50dc7993c7d7208f985c3f93821448236da7d3a64102de8e835a93f7b8e85670a5c932f27f6310b050d282a8b53c7b4c506a1afab4712d86904798cd50e55223c97d93545ea34536a32938e967c5c721ab7642e6307b68ed1e686db787a60f7efcdc7a17dae27c3c2eeb950882433880cfeb80d551bb43c4acb6b2c1f96a1d87e513067c005f39b7c6eaecbc00f6555d58e9669dba0ff2c849b0515276857a959d400c42917051a9f5b407d083a732fcff5040df895f9675ff9c6af050a4ea309e84be6f03043821bbe1076d40cf8c98b1f59cbdbc577396e4de3caebe2db42f073f368422f290e87785fc91522b024921f28006b3a274d4e11cb530a07d0a5414f7ab73a4b327cd4df68866199f94d864a01ff7b6e045e59fd425b89442976d2c547bf289f802e56fe2865dacea903c44a9de29a1c5b9f7115f0835f4267f4aabf188d0a3545e90e36d51759da3ccd31b470fc9f2e36423c8d91e69d61eca452e81ac7a5c79e7df8905b30c4c47d959b017d6c2153b83695d9e2df010f9edbe20fd83739545236cbf0bf53ed46f2b07e21315f48996a1e9c601f7f0a7be2b54759495166595a5b878468d6d4887ab599b3e58c6e8bd9e1931afdce41800dd7e7ea3b90ffd88d307eb3f18c4ad02f1b20fd5f9552ce5fd878d908857a4e31504a4a372896cfdc1360b039e88b73a74bf9bfa42e1001987ecf98ffcd49ecf1f1bf42dbd8e76bc35b6d5080141bdf23e2c3133c25406bab2d2f5c581a7e4cf334cf838fc183d72cadee6c8d90b2f1a6586029c0988f5c639248a25c409bd21c047597fc247036cfa69f0ed3bdb1fc76decf198590ee99b9652d149d3845a5f50ee362fea10266883a5ea5fab78e3f5c7fd4850b0e5de7ec890d7c7668ac5c3882f2541e3b5fffb717b643a43ed1f9bad9225885ad223614fdd34b38b3f8ab41617366f92f7f5d7b83bc9facdff18df7a9f5b82b1bcb6cafa2bb98e8af9f81bac82ade14c93daedc5f336916d40f5f1259419a07bb52cc56dedac7f0e27b5ed13cfd4e1668017c7b96061415cb5469d77bc889c7dad019b3c0c55f9665475160ee2f4b612f9ea59b6223e1f5c989bfe825185d9696473ee88fc55f59921aa24411bca02a71c802624bdf77e9c900a81e3a9fc1d947ecb30b7137ac255da8a11f5c8fb2f2672ca9e749527a868063af4dec44b01423af8c262449c4a80b90ad67361e3c17d2a8f18c3ce1ab94bcc8236baaa3dca233a4f6ae5ede2419ca666ddd40b921376f501a1b07cc9ff12e834707891adbd9ba00c17fa5e75c59b0859dac7c116f80f2552adf9c0eff8e0a94fdeb674fa4a001c07421e9d018685e7a67d3b84446b5c10079569e5b4d31ea54b4b5751131bfcdedc3c3ba5e48f6dc2f98e13aa2dc70ea292122ca2c97f2f82e2ba944df8670a448399b39a7b7dd764ba4e0f2aa5620a94794b21e68f43578ace170a6aa8f214f97cbf4e7aec07cd4fc3e727e0226abf2975c48d586bcf6365dd41543fcb040c9da9f12df9d97fd9617a22ac85d89d8f9e948a7c6440e4a1978b0b8c6839f0e9ddae891de5a8814ca08eefc59f748bb91d89f7540a2a841456367760392f301591886ad07360fc758d37b276ee9cd5df0c6995c8695dd318710904a3fce77917327d6e992dbc36d18679b46de771624d05b3d3a336e3fd4bb4aa7a7ff463fda825bc5c5d3802a6dac37e273674106e240ebb0bdb4fa720306d788217d1f01657e30446c3f2c95d9d7a405898c7d9a0a801d7ac140d28d7fec625fa81b1c949dc4ef24725770ea6055086e961b4aeb5d4ec0b653c33e7e6811ee6fb0455f34307011376f9690589d0c9fa97b976edd2a629bac5f55d27b1e8b1bc3e6c2f21a2c96553e0ba14c83ef7c53e20c722c4952826fb3aadc305c4ea2e7f3b45735259e185bc72ca672dc2e35a16ee1de2398256a4061d55aa4b68e02e8430dc7b9cba907cf2516c269249cd8a7266c99695d6b5e2da9d5d71bba8ca324a56f7bf35dca411da5c8da6ec692b449646197cbf2acf75688ca00b5aa57e79482d937caf3a9b3a9980492323e872364e20c2638eab8805a203cc4fee77ef8b66232a0a36ca1f4c941decf08a547ca4c09dea76b6999af44582301c82018f375e7cf2f6a1c528bfc3b8c9d5ac81c61e1447245a5c187794b68c9d2182556b53244a2115d4d271c1f9e811286de3d4d39789b00300164c08821ff89b4c3fff7be5d596615cadc084b660cbecd6c9169119309babe2ca8ad8be03c09fba43b6742854184bbb8631fa79e7b4c1fa34b2cf26c6e9e23f5deec8d33fb4fd494da8f0d22df80aadfe936bd5d9025a6f1c6ccd459028d4e2c98ac22623969dea5179b7e75dd8a8380e02227950f133ef563765f057a46640ee46a77914e6fdc1a64b1dee5a492c2a83c2252b818ef0b988584ce71dac87aad69d6c74e6f56bbc3398c5db8403a99dc5ee62f20e141461c1e172bfce1fc09334b08aaea371b84775cb571be17e62cd69adda5fcc835c1341f8162f4144cc9f2c2d05bf364f7adf9908291a1276d6c639d969a0869e369df5407951d4aaabc01adfd96919b7779f64446ca888ab2bbee72b5cdd592893455effb1b8b5277ffaa0737ae6b30ce433f2a977e9cb3d07798faa46141515d8213c1b18ca25d26261328a6724804162bd68b1f16abb1dcb476a8a56552396090f0d530b1afbbd13aac77385dac48583f027237c0d2153c616974fcbe7feb610a1d75780d03b1247a16bf27ec879f54fbeb34b30f5450bc37ef57e9279db66a6434d21ef0722120012a5ea30bb78e8245eb614d00c33841a760369837c8c01bc19159fc09fa091528def64ad2d52ae2febd758e1f1bbd927c004e88844e4fbfcfb664817c1f8c2033d0f876d74231fa6ecd179221f3fe57816400bf7409e2fa216ab0351a087f04598ad9377fbaa0a814d4b1d7d0105fddd9d07a20b7d013f5449569377b1cdbb9e29f5966af89217a9734d09cd9b26b148ffa0d203e8584741371b78c7e2bdbcab3c00af45ba5536b7b41cfcae03f594e9985d888ed59ace8a0546fbd03cad4a20721dea18015d9a0cb225e1ce86ef3c7bedb13b7ecae07015d73582022e10029bf2502f0d6b71dee0c09d14f323c07dab2851f2c5ccfcf534aa2684f2895e56def0c222c1ef666e88c5ec93a0884ac0a86276e771a9af05c3fb8986e3b6f2c67740d99e1d822e5d307374790dcc2a266d27230fcde08eef0df2240a4441de48d8e974f554ccb47670632945eeacc4f94826d4dd18ddfc6b06e1b2c5f7dcca0b79ef26da01d905e6f525301d55f70883565d113580dc0ab4b9523a75f6dabb266609cec7742515bb3d285db9939009a9e19b65ba77dd403fdb014e3d2d096ab557cf56557d4106e9cadb3b3f535f290699187d16b8103c58bebd77b07ebec332152a103cf87c0fbc19f4778d3fea322697e1ab62550c72c9bb88498019e24b86b459eaf521acff4b542374fa9462dc7af3891ba6e98956e70f56b50c5b820965a7b68049ab8325034784f45b906c4dfbc83e103bb0459992ac04388baf6437ef6b7e603d9b00d950ff4d4c2259e483800d9acc5eb007403de08ff608861ce5a4379490f9af32776d6a81642847d993747b34aa120cd74c849ae8a0af67d4a8fc37da567dd7a9d217138858c3580a620bc3c0b0c8df6749d0ca398e57a79c5f1e61b9cb96cbe0a202c859a7e5c2566fca725dfa25ecb613bf84d4430368e66db6bd2a3e8c668aa529447372b4097eb745fcf0a847c3caff8ea67fc697dc2b9b69cca32ec0ad730b5e57e3aa7e689448194562629fa66a539660074bf64d673eaa5c467118ec18b0780f796e30374ba11537c7d09a8954d8d12f983f1b5a7406e0dbf7d9d9df0d46bb3a3f475f62603f6fdb96aac71ea4546480c5395e850b62bbea4025d6c63d71a6083e8ef3767a1145463ac6b151f592774487ffb267c88cb05831b7e509916f4e6d346638e289b113148712093bd3b684cddffe5ad2aa0d82f2374fb7e10a0d55bc9189942dd42fbb4e52af232ac9916a3074c50e80b4a6fb0de5aa72f190c37d654da8d041e42368b21dfdf68a8f0a789d0f731ab04a8568ff2b0cb69474a45063c5d06832e2706016a5653eac751c6107ab5253690221ad32c03e92a0f6ad10292ba53e718a2fe65dfae10b2025ea5ce88f815dd93827591111dc27bc60d867b282cf6e9d57d9886c12b142fc5de87e488afcb2d2bfa9822504ed438878d40c3193f176e90742201b7959b6110cf4146af72a01d201ea30f4116b8e05b37e2d7cffc69776d31cee15e9bea92403a0a4a30321414807b9c911a540060fb34976e8b01a5ecc26cb21d00c58502b065d5a2218dfaf8cc654357bf962ff49725e5f5948f3608fb5917a4edb1d8e45187efc8b8216c23ba05da21843617f5b09c3479c34997897d8162a0cfbccc1be9eddc7bfca6bf09219a85396a872138862d4c7ee5eb33c2679145c6be61e36609e4bfa6a5f1a8487e88b84d7adc9dfed94984d0edb1d9f69984f6cf46f305bd45aaa88815428175c3024d0470fdfd9d01c9291b3698c4b0723cd3029b905d916c7347a7f3d18537f038c9f6863413d18c722801bdd334fd52a6d2fc6071893a096f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"d8b6287715ace663fbdfeee1ae2b7c7f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
